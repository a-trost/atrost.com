# GraphQL
Learned from howtographql.com (Which seems to be created by prisma.io)

## What is GraphQL?

* Declarative data fetching
* Single Endpoint

REST was fine for when applications were simpler and development times weren't as fast.

GraphQL minimizes the amount of data getting transferred because you're only asking for what you need. This makes your apps faster.

It's hard for a REST endpoint to suit itself well to many different frontends.

The way that REST APIs need to be continually modified to account for different requirements slows down production time. Instead of having to wait for your backend to update to handle the frontend needs, the frontend just changes their request.

## GraphQL is the better REST

REST endpoints result in under-fetching and over-fetching when you're calling for your data. Having worked on a production app with a REST endpoint, I know what this is like. We needed to hit several endpoints to flesh out a single page, and when the designs changed, I needed to get another developer to change the way the API worked, or open a new endpoint.

GraphQL uses 'resolver functions' to get the data. I'm assuming this will work similarly to Redux's or RxJS's resolvers.

GraphQL is strongly typed to define the capabilities of an API. Without this I doubt a lot of the filtering features would work.

Creating the typed schema up front allows for a sort of contract between the frontend and backend. This way the frontend can mock their data for testing while the backend is being created.

## GraphQL Core Concepts

GraphQL has a "Schema Definition Language" or SDL. This is where you define the types.

If there is an exclamation point following the type, it's required.

```
type Person {
	name: String!
	age: Int!
}
```

Line breaks, not commas or semicolons, are what start the next value.

### Adding Relations

We can add related fields like this. Make sure you don't use a protected word for the name of your schema.

```
type Person {
	name: String!
	age: Int!
	posts:[Post!]!
}
```

```
type Post {
	title: String!
	author: Person!
}
```

### Fetching Data with Queries

```
{
	allPersons {
		name
	}
}
```

Here the `allPersons` field is the *root* of the query and everything that follows the root field is the *payload*.

You can specify params with parentheses after the field like this:

```
{
	allPersons(last: 3) {
		name
	}
}
```

That `last` argument is specified in the schema.

### Writing Data with Mutations

With GraphQL we update data in the DB with *mutations*. I haven't done much of this because of the read-only nature of Gatsby's GraphQL, so this is new territory. 

They follow the same syntax structure but start with the `mutation` keyword. 

```
mutation {
	createPerson(name:"Bob", age:32) {
		name
		age
	}
}
```

`createPerson` is a root field. It takes two args that specify the name and age. The `name` and `age` part inside the query is just asking for the data back. 

GraphQL Types have unique IDs generated by the server.

### Subscriptions

GraphQL has this amazing feature called Subscriptions that allows for live data streaming. You subscribe to an event and get updated with new data whenever the event fires. 

This seems to be implementing websockets, and it's just amazing that you get this out of the box with GraphQL. This seems like it should solve some of the issues we're experiencing with making live previews and things for Static sites.

```
subscription {
  newPerson {
    name
    age
  }
}
```

The client sends this subscription to the server, and the server knows to send that requested data along whenever the `newPerson` event fires.

This eliminates any need for polling. I'm wondering how fast this works. Would this be usable in a chat app, or is there too much latency?

### Writing an actual GraphQL Schema

The schema is one of the most important concepts when working with a GraphQL API. I like that the contractual nature of the schema makes things like GraphiQL possible. You know exactly what the data looks like, and you can use nice GUIs with it.

When writing a schema there are a couple special *root* types. I'm familiar with Query, not Mutation or Subscription.

```
type Query { ... }
type Mutation { ... }
type Subscription { ... }
```

We enable queries, mutations and subscriptions by defining them inside each of those types. 

To define `allPersons` we do this:

```
type Query {
	allPersons: [Person!]!
}
```
`allpersons` is an array of `Person` where everything's required.

In the example we queried for `last` to give us the most recent `Person` objects. We need to add that to the schema like this:

```
type Query {
	allPersons(last: Int): [Person!]!
}
```
It's not required so no `!`. I'm not sure how we make the `last` argument functional. I'm assuming that comes later. Right now I'm guessing it wouldn't do anything.

For the mutations we define the arguments in the same way and point it to the type `Person`.

```
type Mutation {
  createPerson(name: String!, age: Int!): Person!
}
```

The subscription is interesting:
```
type Subscription {
  newPerson: Person!
}
```

I would have expected it to reference `createPerson`. I'm curious to see how we wire all these up.